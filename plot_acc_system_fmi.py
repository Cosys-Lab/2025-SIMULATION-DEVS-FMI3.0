"""
2025-SIMULATION-DEVS-FMI3.0
Copyright (C) 2025 Cosys-lab, University of Antwerp

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

# Plot results (Contains code generated by ChatGPT)
import pandas as pd
import matplotlib.pyplot as plt
import base64
import pickle
import numpy as np
import h5py
import os

# mpl.use('Qt5Agg')

def plot(file_path):
    # Load the CSV
    data = pd.read_csv(file_path)

    # print("Column Names:", data.columns)
    # print(data.head())

    # Function to decode and unpickle the data
    def decode_and_unpickle(value):
        if pd.isna(value):  # Handle missing values
            return None
        try:
            decoded = base64.b64decode(value)
            return pickle.loads(decoded)[0]
        except Exception as e:
            print(f"Error decoding value: {value}, Error: {e}")
            return None

    # Extract the required columns
    time = data['time']
    ego_vehicle_state_data = data['ego_vehicle.vehicle_state_data'].copy()
    lead_vehicle_state_data = data['lead_vehicle.vehicle_state_data'].copy()
    speed_controller_output_data = data['speed_controller.output_data'].copy()
    supervisor_output_data = data['supervisor.output_data'].copy()

    ego_vehicle_state = ego_vehicle_state_data.apply(decode_and_unpickle)
    lead_vehicle_state = lead_vehicle_state_data.apply(decode_and_unpickle)
    speed_controller_output = speed_controller_output_data.apply(decode_and_unpickle)
    supervisor_output = supervisor_output_data.apply(decode_and_unpickle)

    # Convert to separate lists for plotting
    ego_time = time  # Extract time
    ego_position = ego_vehicle_state.apply(
        lambda x: x[0] if isinstance(x, list) and len(x) > 0 else None)  # Extract position (x)
    ego_speed = ego_vehicle_state.apply(
        lambda x: x[1] if isinstance(x, list) and len(x) > 0 else None)  # Extract speed (v)
    ego_accel = ego_vehicle_state.apply(
        lambda x: x[2] if isinstance(x, list) and len(x) > 0 else None)  # Extract acceleration (a)

    lead_time = time  # Extract time
    lead_position = lead_vehicle_state.apply(
        lambda x: x[0] if isinstance(x, list) and len(x) > 0 else None)  # Extract position (x)
    lead_speed = lead_vehicle_state.apply(
        lambda x: x[1] if isinstance(x, list) and len(x) > 0 else None)  # Extract speed (v)
    lead_accel = lead_vehicle_state.apply(
        lambda x: x[2] if isinstance(x, list) and len(x) > 0 else None)  # Extract acceleration (a)

    time_speed = time  # Extract time
    wanted_speed = supervisor_output  # Extract wanted speed (v)

    time_acceleration = time  # Extract time
    wanted_acceleration = speed_controller_output  # Extract wanted acceleration (a)

    # Create the plot
    plt.figure(figsize=(16, 16))

    # Plot position over time
    lead_position_interpolated = np.interp(ego_time, lead_time, lead_position)
    distance = lead_position_interpolated - ego_position
    safe_distance = 10.0 + 1.4 * np.array(ego_speed, dtype=float)

    plt.rcParams.update({'font.size': 28})
    plt.rcParams.update({'legend.loc': 'best'})
    line_width = 4.0

    plt.subplot(3, 1, 1)
    plt.plot(ego_time, distance, label='Actual', linestyle='-', drawstyle='steps-post', linewidth=line_width)
    plt.plot(ego_time, safe_distance, label='Safe', linestyle='--', drawstyle='steps-post', linewidth=line_width)
    plt.ylabel('\nDistance (m)')
    plt.xlabel('Time (s)')
    plt.title('Distance Between Vehicles')
    plt.legend(ncol=2)
    plt.grid(True)

    # Plot speed over time
    plt.subplot(3, 1, 2)
    plt.plot(lead_time, lead_speed, label='Lead', linestyle='-', drawstyle='steps-post', linewidth=line_width)
    plt.plot(ego_time, ego_speed, label='Ego Actual', linestyle='--', drawstyle='steps-post', linewidth=line_width)
    plt.plot(time_speed, wanted_speed, label='Ego Wanted', linestyle='-.', drawstyle='steps-post', linewidth=line_width)
    plt.ylabel('\nSpeed (m/s)')
    plt.xlabel('Time (s)')
    plt.title('Vehicle Speeds')
    plt.legend(ncol=3)
    plt.grid(True)

    # Plot acceleration over time
    plt.subplot(3, 1, 3)
    plt.plot(lead_time, lead_accel, label='Lead', linestyle='-', drawstyle='steps-post', linewidth=line_width)
    plt.plot(ego_time, ego_accel, label='Ego Actual', linestyle='--', drawstyle='steps-post', linewidth=line_width)
    plt.plot(time_acceleration, wanted_acceleration, label='Ego Wanted', linestyle='-.', drawstyle='steps-post', linewidth=line_width)
    plt.ylabel('Acceleration\n(m/(s^2))')
    plt.xlabel('Time (s)')
    plt.title('Vehicle Accelerations')
    plt.legend(ncol=3)
    plt.grid(True)

    # Adjust layout, and show and save the plots
    plt.suptitle("FMI")
    plt.tight_layout()
    os.makedirs('.\\traces\\plots\\', exist_ok=True)
    plt.savefig(".\\traces\\plots\\acc_system_fmi.pdf", format="pdf", bbox_inches="tight")
    plt.savefig(".\\traces\\plots\\acc_system_fmi.png", format="png", bbox_inches="tight")
    plt.show(block=False)
    plt.pause(0.001)

    # Save data to hdf5 file
    os.makedirs('.\\traces\\hdf5\\', exist_ok=True)
    with h5py.File('.\\traces\\hdf5\\acc_system_fmi.h5', 'w') as hf:
        hf.create_dataset('ego_time', data=ego_time)
        hf.create_dataset('ego_position', data=ego_position)
        hf.create_dataset('ego_speed', data=ego_speed)
        hf.create_dataset('ego_accel', data=ego_accel)

        hf.create_dataset('lead_time', data=lead_time)
        hf.create_dataset('lead_position', data=lead_position)
        hf.create_dataset('lead_speed', data=lead_speed)
        hf.create_dataset('lead_accel', data=lead_accel)

        hf.create_dataset('time_speed', data=time_speed)
        hf.create_dataset('wanted_speed', data=wanted_speed)

        hf.create_dataset('time_acceleration', data=time_acceleration)
        hf.create_dataset('wanted_acceleration', data=wanted_acceleration)


if __name__ == "__main__":
    plot('.\\traces\\acc_system_fmi.csv')
